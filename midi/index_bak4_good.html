<!DOCTYPE HTML>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-8"> 
        <script src="stream.js"></script>
        <script src="midifile.js"></script>
        <script src="replayer.js"></script>
        <script src="synth.js"></script>
        <script src="audio.js"></script>
        <script src="vbscript.js"></script>
        <script type="text/javascript">
        function loadRemote(path, callback) {
            var fetch = new XMLHttpRequest();
            fetch.open('GET', path);
            if (fetch.overrideMimeType) fetch.overrideMimeType("text/plain; charset=x-user-defined"); // not work for IE.
            else fetch.setRequestHeader('Accept-Charset', 'x-user-defined');
            fetch.onreadystatechange = function() {
                if(this.readyState == 4 && this.status == 200) {
                    /* munge response into a binary string */
                    var t;
                  if (IE_HACK) {
                    // http://stackoverflow.com/questions/1919972/how-do-i-access-xhr-responsebody-for-binary-data-from-javascript-in-ie
                    // https://code.google.com/p/jsdap/source/browse/trunk/?r=64
                    t = BinaryToArray(fetch.responseBody).toArray();
                    var ff = [];
                    var mx = t.length;
                    var scc= String.fromCharCode;
                    for (var z = 0; z < mx; z++) {
                        //ff[z] = scc(t.charCodeAt(z) & 255);
                        ff[z] = scc(t[z]); // t[z] here is equivalent to 't.charCodeAt(z) & 255' below.
                                           // e.g., t[z] is 238, below t.charCodeAt[z] is 63470. 63470 & 255 = 238.
                                           // but IE8 has no Audio element, so can't play anyway.
                    }
                    callback(ff.join(""));
                  } else {
                    var t = this.responseText || "" ;
                    var ff = [];
                    var mx = t.length;
                    var scc= String.fromCharCode;
                    for (var z = 0; z < mx; z++) {
                        ff[z] = scc(t.charCodeAt(z) & 255);
                    }
                    callback(ff.join(""));
                  }
                }
            }
            fetch.send();
        }
            

    //http://stackoverflow.com/questions/2856513/how-can-i-trigger-an-onchange-event-manually
    function fireEventEnded(target) {
        if (document.createEvent) {
            var evt = document.createEvent("HTMLEvents");
            evt.initEvent("ended", false, true);
            target.dispatchEvent(evt);
        }
        else if (document.createEventObject) {   // IE before version 9
            var myEvent = document.createEventObject();
            document.getElementById('music').fireEvent('onclick', myEvent);
        }
    }

    if (typeof (MidiPlayer) == 'undefined') {

        /** 
         * Constructor of MidiPlayer class. 
         * @param midi Midi file to play.
         * @param target Target html element that this midiplayer is attached to.
         * @param loop Whether loop the play. optional, default is false.
         * @param debug_div If not empty, write debug message to this div.
         */
        var MidiPlayer = function(midi, target, loop, debug_div_id) {
            this.midi = midi;
            this.target = document.getElementById(target);
            this.loop = (typeof (loop) == 'undefined') ? false : loop;
            this.debug_div = (typeof (debug_div_id) == 'undefined') ? 
                             null : document.getElementById(debug_div_id);
            this.midiFile = '';
            this.synth = '';
            this.replayer = '';
            this.audio = null;
            this.ct = 0; // loop counter.
            this.max_loop_ct = 0; // max number of loops. if <= 0, means infinite.
            this.started = false; // state of play started/stopped.
        }

        MidiPlayer.prototype.debug = function(msg) {
            if (this.debug_div) {
                this.debug_div.innerHTML += msg + '<br/>';
            }
        }

        MidiPlayer.prototype.setMaxLoop = function(v) { 
            this.max_loop_ct = v;
        }

        MidiPlayer.prototype.stop = function() {
            this.started = false;
            this.target.value = 'play';
            if (this.audio) { this.audio.stop(); }
        }

        MidiPlayer.prototype.play = function() {
            if (this.started) {
                this.stop();
                return;
            }

            this.started = true;
            var o = this.target;
            o.value = 'stop';

            var _this = this; // must be 'var', otherwise _this is public, and causes problem.
            var file = this.midi;
            var loop = this.loop;

            if (loop) {
                if (window.addEventListener) {
                    // Second time calling play() should not add another listener, otherwise o has
                    // more and more listeners, and will fire n events the n-th time calling play.
                    if (this.ct == 0) {
                        o.addEventListener('ended', function() { // addEventListener not work for IE8.
                            //_this.debug('4: ct = ' + _this.ct);
                            //alert('ended');
                            _this.ct += 1;
                            if (_this.max_loop_ct <= 0 || _this.ct < _this.max_loop_ct) {
                                _this.replayer = Replayer(_this.midiFile, _this.synth); 
                                _this.audio = AudioPlayer(_this.replayer, o, loop);
                                _this.debug( file + ': loop ' + _this.ct );
                            }
                        }, false);
                     }
                 } else if (window.attachEvent) { // IE don't work anyway.
                     //document.getElementById('music').attachEvent(
                     //    'onclick', function(e) { alert('IE end'); }, true);
                 }
             } // end of: if (loop)

             // Not how "this" is passed into the closure!
             loadRemote(file, function(data) {
                 if (_this.ct == 0) {
                     _this.midiFile = MidiFile(data);
                     _this.synth = Synth(44100);
                 }
                 _this.replayer = Replayer(_this.midiFile, _this.synth);
                 _this.audio = AudioPlayer(_this.replayer, o, loop);
                 //alert(audio.type); // webkit for firefox, chrome; flash for opera/safari.
            });
        }
    }

    var mp1, mp2;
    function init() {
        mp1 = new MidiPlayer('Saved.mid', 'm1', true, 'msg');
        mp2 = new MidiPlayer('Bach.mid', 'm2', false, 'msg');
    }
        </script>
    </head>
    <body onload="javascript:init();">
        Save.mid:
        <input type="button" value="play" id="m1" onclick="javascript: mp1.play(); "/> <br/>
        Bach.mid:
        <input type="button" value="play" id='m2' onclick="javascript: mp2.play();"/>

        <br/><div id='msg'></div>

    </body>
</html>

